---
layout:     post
title:      How I Built a Light Show in my Dorm Room
author:     Camdan Mead
date:       2025-01-24 12:31:19
summary:    This is how I built a light show in my dorm room.
categories: projects
listed:     false
---

> This is a draft of a video script, it is not currently written in article form and needs more work.

I built a light show in my dorm room. Here’s how.

I’m not totally sure what to call this thing. In my head I’ve mostly just been calling it a hexagon, which I figure is a relatively accurate description. Anyway, this is how it came to be.

So, I do this thing where every year I have some big overarching project to work on. Junior year of high school I made a big short film, which ended up taking nearly two years and taught me that I actually don’t like filmmaking that much, and senior year I planned and organized a TEDx event. But, when I got to college, I figured I’d probably be too busy with homework and wouldn’t have time for a project.

That was until I was in the shower one day and had an idea to make a light show. I taught myself lighting design in high school and at the time was in the process of breaking into the entertainment industry, but didn’t really have a way to scratch that lighting itch in college. The only problem with my dorm light show idea was professional lighting fixtures are really expensive. So, I decided to build my own, and ended up learning the hard way why they cost that much.

I knew I didn’t want my fixture to move and was just essentially going to be fancy LED strips, so I just needed a shape for them. I was first inspired by Odesza’s massive overhead hexagon set piece, but realized I could connect three of the points to the center to make it into a sort of isometric cube. I then remembered that my own logo was also inspired by an isometric cube, so I could also light it up in the shape of my logo which is pretty cool.

Having settled on a design, I sat down to draw it out, and then immediately remembered that I didn’t know how to use CAD and definitely didn’t feel like learning now, I wanted to build. So I decided I would make it out of 2x4s. I hopped on a bus and headed off to Home Depot to pick up some wood, where I quickly learned two important facts. First, turns out 2x4s are not actually 2in by 4in. Second, bus drivers really aren’t keen on you bringing long pieces of wood on the bus and will refuse to let you on. So, forgetting I had friends who would happily come pick me up, I walked 45mins back to school carrying two 8ft 2x4s and headed to the wood shop.

When I got there, I arbitrarily chose dimensions for the wood members that I felt would be a good size, and cut the 2x4s down to roughly those dimensions. I then also arbitrarily chose that 4ft was a good height for the hexagon, so I cut the members to those dimensions. Unfortunately, I was really bad at math at the time, so took a “don’t measure at all, cut ten times” approach where I just laid the wood down on the floor and marked with a pencil where the cuts should go. That’s probably why the finished product is so warped. I then realized that my initial idea of screwing everything together wouldn’t work because I didn’t make any places for the screws to go, so I had to glue it, which is really really hard when the wood dimensions were chosen at random and cut with the precision of a drunk monkey. Finally, after hours of work, I had a bare wooden hexagon. I took a step back and realized that I had completely forgotten my original idea and connected all six points of the hexagon to the center instead of just the three to create the isometric cube shape, but that ended up actually making it pretty cool so it all worked out in the end.

Then came the electronics. Luckily I’m better at those than woodworking. Anyone who has ever worked with an arduino and lights before is probably familiar with Neopixels, which are what Adafruit calls their product line of addressable RGB LEDs. Neopixels are actually just a rebadge of a very common ARGB LED package called a WS2812B. Adafruit sells them for almost 50 cents apiece, but they’re actually only worth about four cents, so you can find them for cheap on Amazon. So I measured my hexagon and ordered a few rolls of WS2812B strips that I was planning on just gluing to the hexagon and controlling with an arduino uno. If only it were that simple.

The first big roadblock I encountered was how much power these things need. Each one draws roughly a quarter watt at full brightness. After some quick math I realized my design would use nearly a thousand LEDs, so I needed to come up with a way to supply roughly 250 watts. This isn’t necessarily a lot of power, it’s roughly what a high-end laptop or midrange PC would draw under load. What makes it hard to manage, though, is that these LEDs run at 5 volts, so together they’ll draw up to 50 amps. That’s a relatively significant amount of current. For reference, an arduino can only supply about 20mA through each pin, your computer’s USB ports can probably output about half an amp, where most wall USB chargers supply at most 2 or 3 amps.

Luckily, amazon has everything and I was able to find a power supply that could run 60 amps at 5v, which was perfect. It’s a little terrifying, with 120v terminals left exposed. Of course, any machine can be a smoke machine if you use it wrong enough, but this power supply felt like I didn’t have to use it very wrong to get to that point. What made it awesome though is that it was only like 50 bucks. Who needs safety when you can save money, right?

So, I got the power supply and LEDs in and hooked them up to an arduino to test. That’s when I encountered my next roadblock. This section is a bit dense, but bear with me. While I had worked with Neopixels before, I had only ever used small strips, maybe 30 LEDs max. When working with more than that, there’s more considerations. The first big problem is that Neopixels are relatively slow. Remember, the data for the whole strip is sent down one pin. They run at 800 kilohertz, and each pixel takes 8-bit RGB data, or 24 bits per update. If I have a strip of a thousand LEDs, each update is 24,000 bits which at 800 kilohertz takes 30 milliseconds to send. That may not sound like a lot, but that places the absolute upper limit of the refresh rate of the hexagon at about 33 hertz. That may not sound too bad, but there’s more. The second problem is that arduinos have only one core and can only think about one thing at once, and remember that I wanted to control this thing from my computer in realtime. That means that it can’t read serial data from the computer and write data to the strips at the same time, which adds processing overhead. To be fair, the arduino runs quite a lot faster than the neopixels, with a baud rate that can be pushed to around four million. This would mean that assuming 24 thousands bits need to be sent for each update, it would take about 6ms to send that data. Unfortunately, that doesn’t account for error correction. There’s tons of ways to do this, but one of the easiest is to just send a few extra bits with each color byte indicating which color its referring to, along with a start byte at the beginning of a new sequence. This doesn’t add a ton of extra data, but it’s worth noting. Finally, there’s the problem of data degradation. While each Neopixel does act as a data repeater, it doesn’t amplify the data, which means over long strands the data pulse amplitude may not be high enough to cross the threshold voltage which an lead to weird behavior.

The solution to these problems seems obvious, just split up the strips use more pins on the arduino. I tried this, switching to an Arduino Mega (which actually helpfully has a faster processor), but I still had the exact same issue. That’s when I remembered the first problem: the arduino is slow and dumb. It’s not designed for high-frequency data conversion and transmission, it can still only think about one thing at once. It would just update one strip down one pin, and then update the next strip down the next pin, only sending one pin of data at a time. So, while using more pins fixed the data degradation issue, it didn’t fix the speed issue.

Around this time I was taking a digital logic course and leaning how to program FPGAs, so I thought that’d be my solution. An oversimplification of my plan was to simultaneously read data via serial from the computer and write that data down all the output pins to the neopixels, by having one process write the serial data to memory and another simultaneously read that from memory and pass it along. This would mean that my speed is only limited by the longest NeoPixel strip, or the data transmission rate from the computer, whichever is slower. If it was done this way, the updating could be totally asynchronous, where it doesn’t matter at what point the data is in its transmission process when it is read and sent to the neopixels. The roadblock here, though, is that the programming language for FPGAs, called Verilog, is incredibly painful to write if you’re not en embedded systems engineer with years of experience, which I’m not. I actually managed to get it sort of working because the Neopixel protocol is super simple, but my code was a buggy mess and Verilog has very little support online because it’s rarely used by hobbyists and most engineers that use it work in secret for big chip manufacturers.

So, basically, I needed to find a multi-core arduino. As it turns out, that totally exists! In fact, there’s even a version of the Arduino mega that uses a FPGA to emulate multiple cores which is pretty cool. But, in my research, I discovered an even simpler solution. The Teensy is basically an unreasonably powerful board for its price with an ARM Cortex M7 chip in a teensy form factor (hence its name). Even better, it’s fully compatible with the Arduino IDE, so I didn’t need to learn a new language or new environment. Better yet, the guy who makes it has a library called OctoWS2811, a library that uses almost the exact same strategy I was trying to reinvent before to simultaneously control multiple strips. It’s a relatively old library, originally intended to control up to 8 strips, but a slightly modified version running on the Teensy 4.1 can in theory control up to 35 strips simultaneously. Of course there had to be a problem, though. The teensy, in all its awesomeness, runs at 3.3v, whereas the Neopixels run at 5v. No problem, I’d just need to step up that voltage. That can be done with any transistor that can run at a reasonably high frequency, which is basically all of them. Fortunately, the guy who made the OctoWS2811 library thought of this, and actually made an adaptor board! Which is really cool, except because the original library was only designed to output to eight neopixels the board only has eight outputs, and I had already decided to break the hexagon up into 12 strips. So, while I had half-assed the rest of the project, for some reason I decided to full-ass this. I sat down, taught myself ECAD, and designed a PCB that would adapt my Teensy 4.1 to output to 24 NeoPixel strips.

While I was waiting for my adaptor board to arrive, it was time to finish building the hexagon. Gluing the strips on was pretty easy, I just cut and soldered them to length, and the hexagon build was actually accurate enough that the strip lengths were all within an LED or two of each other, which was convenient. The wiring, though, was far less convenient. What I should have done was just mount the teensy behind the hexagon, because it’s easily small enough to fit back there and be invisible. That would be the smartest thing to do. For some reason, that idea never occurred to me, so I designed a custom cable to carry all of the power and data from the power supply and Teensy. Making that one cable took nearly 10 hours of work and was one of the most painful things I’ve ever built. In the end, though, it carries the high current power lines and 12 individual data lines to the hexagon. It really sucked to make, but it actually worked first try, so I guess it’s worth it.

Finally, the adaptor arrived and it was time to put everything together. To my amazement, it actually all worked, which was awesome. It looked even cooler than I had hoped. All that was left was to figure out how to control it.

To my surprise, this was by far the easiest part of the process. I just used a software called xLights, which is a software people use to script light shows for their christmas lights on their house. It was pretty easy to learn, and although it has literally no documentation to speak of, reverse engineering its serial communication protocol was pretty easy. So, I set it all up, programmed the teensy, and ran my light show. Check it out.